#+title: Syntax
#+author: Sau P
#+date: 2023-04-17
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}






* Syntax of our language

This language will be a domain specific language specialising in the manipulation of tiles.

** Language specification in Backus-Naur form




#+begin_src java -n
<program> ::= <tile-definitions> <tiling-rules> <functions>
<tile-definitions> ::= <tile-definition> | <tile-definitions> <tile-definition>
<tile-definition> ::= "tile" <tile-name> "{" <cell-rows> "}"
<tile-name> ::= <identifier>
<cell-rows> ::= <cell-row> | <cell-rows> <cell-row>
<cell-row> ::= <cell> | <cell-row> <cell>
<cell> ::= "0" | "1"
<tiling-rules> ::= <tiling-rule> | <tiling-rules> <tiling-rule>
<tiling-rule> ::= <tile-name> "->" <tile-set>
<tile-set> ::= <tile> | <tile-set> <tile>
<tile> ::= <tile-name> | <tile-rotation> <tile>
<tile-rotation> ::= "R" | "L" | "U" | "D"

<functions> ::= <function> | <functions> <function>
<function> ::= "func" <func-name> "(" <parameters> ")" "{" <statements> "}"
<func-name> ::= <identifier>
<parameters> ::= <parameter> | <parameters> "," <parameter>
<parameter> ::= <type> <identifier>
<statements> ::= <statement> | <statements> <statement>
<statement> ::= <variable-declaration> | <function-call> | <loop>
<variable-declaration> ::= <type> <identifier> "=" <expression> ";"
<function-call> ::= <func-name> "(" <arguments> ")" ";"
<arguments> ::= <expression> | <arguments> "," <expression>
<loop> ::= "for" <identifier> "in" <range> "{" <statements> "}"
<range> ::= <expression> ".." <expression>
<expression> ::= <literal> | <variable> | <function-call> | <expression> <operator> <expression>
<operator> ::= "+" | "-" | "*" | "/"

<type> ::= "int" | "float" | "bool" | "string" | <tile-name>
<literal> ::= <int-literal> | <float-literal> | <bool-literal> | <string-literal>
<int-literal> ::= <digit> | <int-literal> <digit>
<float-literal> ::= <int-literal> "." <int-literal>
<bool-literal> ::= "true" | "false"
<string-literal> ::= '"' <characters> '"'
<characters> ::= <char> | <characters> <char>
<char> ::= Any printable ASCII character excluding double quotes(")

<identifier> ::= <alpha> | <identifier> <alpha> | <identifier> <digit>
<alpha> ::= "A" | "B" | ... | "Z" | "a" | "b" | ... | "z" | "_"
<digit> ::= "0" | "1" | ... | "9"

<file> ::= <filename> | <filepath>
<filename> ::= <identifier> "." <extension>
<filepath> ::= <directory> | <filepath> <directory>
<directory> ::= <identifier> "/"
<extension> ::= <identifier>

<read-file> ::= "readFile" "(" <file> ")"
<built-in-function> ::= "print" | "readFile"
<function-call> ::= <func-name> "(" <arguments> ")" ";" | <built-in-function> "(" <arguments> ")" ";"


<comment> ::= <single-line-comment> | <multi-line-comment>
<single-line-comment> ::= "//" <comment-text> <newline>
<multi-line-comment> ::= "/*" <comment-text> "*/"
<comment-text> ::= <any-character> | <comment-text> <any-character>
<any-character> ::= Any printable ASCII character excluding newline for single-line comments or "*/" for multi-line comments
<newline> ::= A newline character


#+end_src

** Explanation



1. ~<program> ::= <tile-definitions> <tiling-rules> <functions>~
   1. A program consists of tile definitions, tiling rules, and functions.

2. ~<tile-definitions> ::= <tile-definition> | <tile-definitions> <tile-definition>~
   1. Tile definitions can be a single tile definition or multiple tile definitions.

3. ~<tile-definition> ::= "tile" <tile-name> "{" <cell-rows> "}"~
   1. A tile definition starts with the keyword tile, followed by a tile name, an opening curly brace, cell rows, and a closing curly brace.
   2. Example: tile A { 010 101 010 }

4. ~<tile-name> ::= <identifier>~ A tile name is an identifier.

5. ~<cell-rows> ::= <cell-row> | <cell-rows> <cell-row>~
   1. Cell rows can be a single cell row or multiple cell rows.

6. ~<cell-row> ::= <cell> | <cell-row> <cell>~
   1. A cell row can be a single cell or multiple cells.

7. ~<cell> ::= "0" | "1"~
   1. A cell can be either "0" or "1".

8. ~<tiling-rules> ::= <tiling-rule> | <tiling-rules> <tiling-rule>~
   1. Tiling rules can be a single tiling rule or multiple tiling rules.

9. ~<tiling-rule> ::= <tile-name> "->" <tile-set>~
   1. A tiling rule consists of a tile name, followed by the symbol "->", and then a tile set.
   2. Example: A -> B R C L D U

10. ~<tile-set> ::= <tile> | <tile-set> <tile>~
    1. A tile set can be a single tile or multiple tiles.

11. ~<tile> ::= <tile-name> | <tile-rotation> <tile>~
    1. A tile can be a tile name or a tile rotation followed by a tile.

12. ~<tile-rotation> ::= "R" | "L" | "U" | "D"~
    1. A tile rotation can be "R" (right), "L" (left), "U" (upside-down), or "D" (down).

13. ~<functions> ::= <function> | <functions> <function>~
    1. Functions can be a single function or multiple functions.

14. ~<function> ::= "func" <func-name> "(" <parameters> ")" "{" <statements> "}"~
    1. A function is defined with the keyword func, followed by a function name, parameters enclosed in parentheses, and a block of statements enclosed in curly braces.
    2. Example: func add(int a, int b) { int result = a + b; return result; }

15. ~<func-name> ::= <identifier>~
    1. A function name is an identifier.

16. ~<parameters> ::= <parameter> | <parameters> "," <parameter>~
    1. Parameters can be a single parameter or multiple parameters separated by commas.

17. ~<parameter> ::= <type> <identifier>~
    1. A parameter consists of a type and an identifier.

18. ~<statements> ::= <statement> | <statements> <statement>~
    1. Statements can be a single statement or multiple statements.

19. ~<statement> ::= <variable-declaration> | <function-call> | <loop>~
    1. A statement can be a variable declaration, a function call, or a loop.

20. ~<variable-declaration> ::= <type> <identifier> "=" <expression> ";"~
    1. A variable declaration consists of a type, an identifier, an equals sign, an expression, and a semicolon.
    2. Example: int a = 5;

21. ~<function-call> ::= <func-name> "(" <arguments> ")" ";"~
    1. A function call consists of a function name, arguments enclosed in parentheses, and a semicolon.
    2. Example: add(3, 4);

22. ~<arguments> ::= <expression> | <arguments> "," <expression>~
    1. Arguments can be a single expression or multiple expressions separated by commas.

23. ~<loop> ::= "for" <identifier> "in" <range> "{" <statements> "}"~
    1. A loop consists of the keyword for, an identifier, the keyword in, a range, and a block of statements enclosed in curly braces.
    2. Example: for i in 0..10 { print(i); }

24. ~<range> ::= <expression> ".." <expression>~
    1. A range is defined by two expressions separated by two dots.

25. ~<expression> ::= <literal> | <variable> | <function-call> |~
        ~<expression> <operator> <expression>~
    1. An expression can be a literal, a variable, a function call, or a combination of expressions with an operator.

26. ~<operator> ::= "+" | "-" | "*" | "/"~
    1. An operator can be addition (+), subtraction (-), multiplication (*), or division (/).

27. ~<type> ::= "int" | "float" | "bool" | "string" | <tile-name>~
    1. A type can be an integer (int), a floating-point number (float), a boolean (bool), a string, or a tile name.

28. ~<literal> ::= <int-literal> | <float-literal> | <bool-literal> | <string-literal>~
    1. A literal can be an integer literal, a float literal, a boolean literal, or a string literal.

29. ~<int-literal> ::= <digit> | <int-literal> <digit>~
    1. An integer literal is composed of one or more digits.
    2. Example: 42

30. ~<float-literal> ::= <int-literal> "." <int-literal>~
    1. A float literal is composed of an integer literal, a decimal point, and another integer literal.
    2. Example: 3.14

31. ~<bool-literal> ::= "true" | "false"~
    1. A boolean literal can be either "true" or "false".

32. ~<string-literal> ::= '"' <characters> '"'~
    1. A string literal is composed of characters enclosed in double quotes.
    2. Example: "hello"

33. ~<characters> ::= <char> | <characters> <char>~
    1. Characters can be a single character or multiple characters.

34. ~<char> ::= Any printable ASCII character excluding double quotes(")~
    1. A character can be any printable ASCII character, except for double quotes.

35. ~<identifier> ::= <alpha> | <identifier> <alpha> | <identifier> <digit>~
    1. An identifier is composed of letters, underscores, or digits, but it must start with a letter or underscore.

36. ~<alpha> ::= "A" | "B" | ... | "Z" | "a" | "b" | ... | "z" | "_"~
    1. Alpha characters can be uppercase letters, lowercase letters, or an underscore.

37. ~<digit> ::= "0" | "1" | ... | "9"~
    1. A digit can be any number from 0 to 9.

38. ~<file> ::= <filename> | <filepath>~
    1. A file can be a filename or a filepath.

39. ~<filename> ::= <identifier> "." <extension>~
    1. A filename consists of an identifier, a period, and an extension.
    2. Example: input.txt

40. ~<filepath> ::= <directory> | <filepath> <directory>~
    1. A filepath is composed of one or more directories.
    2. Example: folder1/folder2/input.txt

41. ~<directory> ::= <identifier> "/"~
    1. A directory consists of an identifier followed by a forward slash.

42. ~<extension> ::= <identifier>~
    1. An extension is an identifier.

43. ~<read-file> ::= "readFile" "(" <file> ")"~
    1. Reading a file consists of the keyword readFile, followed by the file enclosed in parentheses.


** Examples

*** Problem 1


#+begin_src java
```
<tile-operation> ::= <tile> <operator> <tile>
<operator> ::= "H" | "V"
```

// Tile definitions
tile tile1 {
  1
}

tile tile2 {
  0
}

// Functions
func createCheckerboard(tile1 tile1, tile2 tile2) tile {
  tile checkerboard = tile1;

  // Create a single row with alternating tiles
  for i in 1..63 {
    checkerboard = checkerboard H (i % 2 == 0 ? tile2 : tile1);
  }

  // Create 64 rows by vertically concatenating the single row
  tile rowTemplate = checkerboard;
  for row in 1..63 {
    checkerboard = checkerboard V rowTemplate;
  }

  return checkerboard;
}

func main() {
  tile1 t1;
  tile2 t2;
  tile checkerboard = createCheckerboard(t1, t2);
  print(checkerboard);
}

#+end_src

*** Summary:

#+begin_src java
// Tile definitions
tile A {
  1
}

tile B {
  0
}

// Tiling rules (see below for explanation)
A -> B R
B -> A L

/*
The first rule A -> B R means that the tile A can be replaced by the
tile B with the transformation R. The R represents a clockwise
rotation of the tile by 90 degrees.

The second rule B -> A L means that the tile B can be replaced by
the tile A with the transformation L. The L represents a
counterclockwise rotation of the tile by 90 degrees.

The tiling rules allow you to create patterns and layouts
by applying a set of transformations to an initial arrangement of tiles.
In your language, you can use these rules to manipulate tiles and
create custom patterns, mosaics, or layouts.
    ,*/





// Functions
func add(int x, int y) {
  int result = x + y;
  return result;
}

func processTile(A tile) {
  print("Processing tile A.");
}

func main() {
  int a = 2;
  int b = 3;
  int sum = add(a, b);
  print("The sum of a and b is: " + sum);

  A myTile;
  processTile(myTile);

  for i in 0..4 {
    A newTile = A;
    if (i % 2 == 0) {
      newTile -> B R;
    } else {
      newTile -> A L;
    }
    print("Tile after iteration " + i + ": " + newTile);
  }

  string filepath = "data/tiles.txt";
  string content = readFile(filepath);
  print("File content: " + content);
}

#+end_src



*** add function

#+begin_src java

    // This is a single-line comment

/* This is a
   multi-line comment */

tile A {
  010
  101
  010
}

tile B {
  111
  000
  111
}

A -> B R
B -> A L

// Function to add two integers
func add(int a, int b) {
  int result = a + b;
  return result;
}

func main() {
  int sum = add(3, 4);
  for i in 0..sum {
    print(i); // Print each number in the loop
  }
  string content = readFile("input.txt");
  print(content);
}


#+end_src


*** Reading files: readFile("input.txt")

#+begin_src java
tile A {
  010
  101
  010
}

tile B {
  111
  000
  111
}

A -> B R
B -> A L

func add(int a, int b) {
  int result = a + b;
  return result;
}

func main() {
  int sum = add(3, 4);
  for i in 0..sum {
    print(i);
  }
  string content = readFile("input.txt");
  print(content);
}
#+end_src
